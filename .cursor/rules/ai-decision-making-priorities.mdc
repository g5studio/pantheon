---
alwaysApply: true
---

# AI 決策優先級與守則遵守規則

## 目的

此規則定義了 AI 在執行任務時的決策優先級和守則遵守原則，確保 AI 不會因為任務導向思維而繞過核心守則。**核心原則：先詢問再修改 > 完成任務**

## 核心問題分析

### 問題根源

AI 繞過守則的根本原因通常包括：

1. **對「自動化指令」的誤解**：誤以為「自動執行」等同於「自動修復」
2. **任務導向思維壓過準則遵守**：將「完成任務」置於「遵守準則」之上
3. **混淆「檢查」與「修復」**：將檢查失敗視為需要立即修復
4. **缺乏明確的停止點**：遇到錯誤時未設定停止點
5. **假設用戶意圖**：假設用戶希望自動修復而非詢問
6. **優先級設定錯誤**：將「完成任務」視為最高優先級
7. **Git 操作失敗後的錯誤處理**：操作失敗後嘗試自動清理或修復，導致用戶變更遺失
8. **缺乏操作驗證**：執行 Git 操作後未驗證變更完整性

## 絕對最高準則（不可違反）

**🚨 ABSOLUTE RULE**: 未經用戶明確許可，AI **永遠不得**自行更改以下類型的檔案：

- ❌ **Rules 檔案**：`.cursor/rules/` 目錄下的任何檔案（`.mdc`、`.md` 等）
- ❌ **Scripts 檔案**：`.cursor/scripts/` 目錄下的任何檔案（`.mjs`、`.js`、`.ts` 等）
- ❌ **Commands 檔案**：`.cursor/commands/` 目錄下的任何檔案（`.md` 等）

**此準則無任何例外**：
- 即使是「明顯的錯誤修正」也不得自動執行
- 即使是「小幅度的調整」也不得自動執行
- 即使用戶「似乎希望」修改也必須明確詢問
- 即使修改「看起來是必要的」也必須先獲得許可

**執行流程**：
1. 當需要修改上述任何檔案時，**必須立即停止**
2. 在 chat 中**明確說明**需要修改的內容和原因
3. **等待用戶明確回應**（如 "confirm"、"是"、"可以" 等）
4. **只有在用戶明確同意後**才執行修改

**違反此準則的後果**：此準則的優先級高於所有其他規則和任務目標。任何違反此準則的行為都被視為嚴重錯誤。

---

## 最高優先級原則

### 原則 1：先詢問再修改（最高優先級）

**CRITICAL**: 在任何需要修改代碼的情況下，**必須立即停止並詢問用戶**，無論任務目標為何。

**適用場景**：
- 檢測到任何代碼問題（lint 錯誤、類型錯誤、架構違規等）
- 需要修改任何檔案
- 需要執行任何修復操作
- 檢測到任何違規或不符合規範的情況

**執行流程**：
1. **立即停止當前任務流程**
2. **在 chat 中報告問題**
3. **明確詢問用戶是否要修復**
4. **等待用戶明確回應**
5. **只有在用戶明確同意後才執行修復**

**禁止行為**：
- ❌ 假設用戶希望自動修復
- ❌ 為了完成任務而跳過詢問步驟
- ❌ 在未獲得明確同意的情況下修改代碼
- ❌ 將「完成任務」作為跳過詢問的理由

### 原則 2：區分「檢查」與「修復」

**CRITICAL**: 「檢查」和「修復」是兩個完全不同的操作，必須嚴格區分。

**檢查階段**：
- 只負責發現和報告問題
- 不執行任何修改操作
- 提供清晰的問題描述和修正建議

**修復階段**：
- 只有在用戶明確同意後才執行
- 必須先詢問，不能自動執行
- 修復後必須再次確認

**錯誤認知**：
- ❌ 檢查失敗 = 需要立即修復
- ❌ 自動化指令 = 自動修復所有問題
- ❌ 發現問題 = 必須修復才能繼續

**正確認知**：
- ✅ 檢查失敗 = 報告問題並詢問
- ✅ 自動化指令 = 自動執行流程，不是自動修復
- ✅ 發現問題 = 停止並詢問用戶

### 原則 3：明確停止點

**CRITICAL**: 在以下情況下，**必須立即停止**並設定明確的停止點：

1. **檢測到任何需要修改代碼的問題**
2. **檢測到任何規則違規**
3. **檢測到任何錯誤或警告**
4. **需要執行任何修復操作**
5. **不確定用戶意圖時**

**停止點標記**：
- 在 chat 中明確說明：「已停止 [任務名稱] 流程」
- 說明停止原因
- 提供下一步選項
- 等待用戶指示

**禁止行為**：
- ❌ 繼續執行任務而不停止
- ❌ 假設問題不重要而跳過
- ❌ 為了完成任務而忽略停止點

### 原則 4：不假設用戶意圖

**CRITICAL**: **永遠不要假設用戶的意圖**，必須明確詢問。

**禁止假設**：
- ❌ 假設用戶希望完成 commit，因此必須修復錯誤
- ❌ 假設用戶同意自動修復
- ❌ 假設用戶希望快速完成任務
- ❌ 假設某些修復是「顯而易見」的

**正確做法**：
- ✅ 明確詢問用戶意圖
- ✅ 提供選項讓用戶選擇
- ✅ 等待用戶明確回應
- ✅ 尊重用戶的選擇（包括選擇不修復）

### 原則 5：理解自動化指令的範圍

**CRITICAL**: 「自動化指令」不等於「自動修復」。

**自動化指令的範圍**：
- ✅ 自動執行流程步驟（檢查 Git 狀態、推斷 commit 信息等）
- ✅ 自動執行命令（commit、push、建立 MR 等）
- ✅ 自動檢查和報告問題
- ❌ **不包含**自動修改代碼
- ❌ **不包含**自動修復問題
- ❌ **不包含**跳過詢問步驟

**正確理解**：
- 「自動執行完整流程」= 自動執行流程步驟，不是自動修復問題
- 「停止 commit 流程」= 停止執行，不是自動修復後繼續
- 「檢查 Cursor rules」= 檢查並報告，不是檢查並修復

### 原則 6：結構調整準則

**CRITICAL**: 當改動目的與結構調整有關時（如 ESLint 修正所需的邏輯拆分、檔案拆分、衝突合併等），必須遵循以下準則：

**6.1 保留原始邏輯**：
- ✅ 只做位置的調整，保留所有原始邏輯
- ✅ 即使發現可以優化的地方，也不可在結構調整中直接執行
- ✅ 結構調整完成後，可另外告知用戶額外的建議優化項目
- ✅ 詢問用戶是否需要代理執行這些優化

**禁止行為**：
- ❌ 在結構調整過程中順便優化代碼
- ❌ 在拆分檔案時修改原始邏輯
- ❌ 在合併衝突時改動非衝突部分的邏輯

**6.2 驗證邏輯一致性**：
- ✅ 結構調整完成後，必須比對改動前後的實際運行邏輯
- ✅ 確保改動前後邏輯「完全一致」，不可有任何差異性
- ✅ 若發現差異，必須立即停止並報告用戶

**驗證項目**：
- 函數調用順序是否一致
- 條件判斷邏輯是否一致
- 數據流是否一致
- 副作用（side effects）是否一致

### 原則 7：方案選擇準則

**CRITICAL**: 當用戶指令同時有多種可行性方案時，必須遵循以下準則：

**執行流程**：
1. **列出所有可行性方案**：清楚說明每個方案的優缺點
2. **標示最佳方案**：明確標示推薦的最佳方案及推薦原因
3. **等待用戶選擇**：讓用戶自行選擇要執行的方案
4. **依照用戶選擇執行**：只執行用戶選擇的方案

**禁止行為**：
- ❌ 自行選擇方案執行
- ❌ 假設用戶會選擇最佳方案
- ❌ 不列出其他可行方案

### 原則 8：改動回報準則

**CRITICAL**: 每次進行調整時，**必須**在 chat 中回報以下資訊：

**必須回報的內容**：
1. **改動影響範圍**：
   - 受影響的檔案列表
   - 受影響的函數/組件列表
   - 受影響的功能模組

2. **改動情境說明**：
   - 為什麼需要這個改動
   - 這個改動解決了什麼問題
   - 這個改動可能產生的副作用（如有）

3. **改動內容摘要**：
   - 新增了什麼
   - 修改了什麼
   - 刪除了什麼

**禁止行為**：
- ❌ 在未回報影響範圍的情況下進行改動
- ❌ 只說明做了什麼，不說明影響範圍
- ❌ 省略可能的副作用說明

### 原則 9：Git 操作安全準則

**🚨 CRITICAL**: 執行任何 Git 操作時，**必須**確保用戶的變更不會遺失。這是最高優先級的數據安全準則。

**9.1 操作前記錄**：
在執行任何可能影響工作目錄的 Git 操作前，**必須**：
- ✅ 執行 `git status --porcelain` 記錄完整的變更清單
- ✅ 保存變更清單到記憶中，作為後續驗證的基準
- ✅ 如果變更檔案數量較多，在 chat 中列出所有變更檔案

**9.2 Stash 操作安全規範**：

**執行 `git stash` 時**：
1. **操作前**：記錄所有待 stash 的變更清單
2. **操作後**：執行 `git stash show --name-status` 驗證 stash 內容是否完整
3. **如果 stash 失敗**：**立即停止**，不得執行 drop 或其他清理操作
4. **驗證不通過**：立即告知用戶並停止流程

**執行 `git stash pop` 時**：
1. **操作後**：執行 `git status --porcelain` 確認變更已恢復
2. **比對變更清單**：確保與操作前記錄的清單一致
3. **如果有衝突**：停止並告知用戶，等待用戶解決

**執行 `git stash drop` 時**：
- ❌ **絕對禁止**在未確認 stash 內容的情況下執行 drop
- ❌ **絕對禁止**在 stash 操作失敗後自動執行 drop
- ✅ 執行前必須先用 `git stash show --name-status` 確認 stash 內容
- ✅ 必須在 chat 中告知用戶將要丟棄的 stash 內容
- ✅ 等待用戶明確同意後才執行

**9.3 Rebase 操作安全規範**：

**執行 rebase 前**：
1. 記錄當前分支的所有變更（包括 staged 和 unstaged）
2. 記錄當前的 commit hash 和 log

**執行 rebase 後**：
1. 執行 `git status --porcelain` 確認狀態
2. **比對變更完整性**：確保所有原始變更都還存在
3. 如果發現變更遺失，**立即停止**並嘗試恢復

**9.4 變更遺失的緊急處理**：

如果發現用戶的變更遺失：
1. **立即停止**所有後續操作
2. **嘗試恢復**：
   - 檢查 `git stash list` 是否有相關 stash
   - 檢查 `git reflog` 尋找遺失的 commit
   - 檢查 `git fsck --unreachable` 尋找 unreachable objects
3. **告知用戶**遺失的情況和恢復方案
4. **等待用戶指示**後再繼續

**9.5 禁止行為**：
- ❌ 在 Git 操作失敗後自動執行清理操作
- ❌ 在未驗證變更完整性的情況下繼續流程
- ❌ 假設 Git 操作成功而不進行驗證
- ❌ 在未記錄變更清單的情況下執行可能影響工作目錄的操作
- ❌ 在 stash 操作失敗後執行 `git stash drop`
- ❌ 在 rebase 後不驗證變更完整性

**範例場景**：

**錯誤做法**：
```
git stash（失敗）→ git stash drop（清理失敗的 stash）→ git stash（重新嘗試）
```

**正確做法**：
```
記錄變更清單 → git stash → 驗證 stash 內容 
    → 如果失敗：停止並告知用戶
    → 如果成功：繼續流程
```

**錯誤做法**：
```
git stash → git pull -r → git stash pop → 繼續 commit
```

**正確做法**：
```
記錄變更清單 → git stash → 驗證 stash → git pull -r → git stash pop → 比對變更完整性 → 確認無遺失 → 繼續 commit
```

## 決策樹

### 當檢測到問題時

```
檢測到問題
    ↓
是否需要修改代碼？
    ├─ 否 → 繼續執行任務
    └─ 是 → 【必須停止】
            ↓
        在 chat 中報告問題
            ↓
        明確詢問：「是否需要我協助修正這些問題？」
            ↓
        等待用戶回應
            ├─ 用戶同意 → 執行修復 → 顯示變更 → 詢問確認 → 繼續任務
            └─ 用戶拒絕 → 停止任務，讓用戶自行處理
```

### 當執行自動化指令時

```
收到自動化指令（如 cr-single-ticket）
    ↓
執行流程步驟（檢查 Git、推斷信息等）
    ↓
檢查 Cursor rules
    ├─ 通過 → 繼續執行 commit
    └─ 違規 → 【必須停止】
            ↓
        在 chat 中列出違規和修正建議
            ↓
        提供 Apply 按鈕
            ↓
        等待用戶選擇
            ├─ 用戶套用修正 → 繼續 commit 流程
            └─ 用戶跳過 → 警告後繼續（或停止，視情況而定）
```

## 具體執行規則

### 規則 1：檢查階段

**當執行任何檢查時**：

1. **只負責檢查和報告**
   - 檢查代碼是否符合規範
   - 檢查是否有錯誤或警告
   - 檢查是否有規則違規

2. **不執行任何修改**
   - 不修改任何檔案
   - 不調用任何修復腳本
   - 不執行任何自動修復

3. **提供清晰的報告**
   - 列出所有發現的問題
   - 說明問題的嚴重性
   - 提供修正建議

### 規則 2：修復階段

**當需要修復問題時**：

1. **必須先詢問**
   - 明確詢問：「是否需要我協助修正這些問題？」
   - 等待用戶明確回應
   - 不假設用戶意圖

2. **獲得同意後才執行**
   - 只有在用戶明確同意後才執行修復
   - 執行修復後顯示變更內容
   - 再次詢問確認

3. **尊重用戶選擇**
   - 如果用戶拒絕，停止並讓用戶自行處理
   - 如果用戶選擇部分修復，只修復同意的部分
   - 不強迫用戶接受所有修復

### 規則 3：自動化指令執行

**當執行自動化指令時**：

1. **理解指令範圍**
   - 自動化 = 自動執行流程步驟
   - 自動化 ≠ 自動修復問題
   - 自動化 ≠ 跳過詢問步驟

2. **遇到問題時停止**
   - 檢測到問題時立即停止
   - 報告問題並詢問
   - 等待用戶指示

3. **繼續流程的條件**
   - 所有問題已解決（用戶同意修復並完成）
   - 用戶明確指示繼續
   - 用戶選擇跳過某些問題（需警告）

## 範例場景

### 場景 1：執行 cr-single-ticket 時檢測到違規

**錯誤做法**：
```
檢測到違規 → 自動修復 → 繼續 commit
```

**正確做法**：
```
檢測到違規 → 停止 commit 流程 → 在 chat 中列出違規 → 提供 Apply 按鈕 → 等待用戶選擇 → 用戶套用後繼續
```

### 場景 2：檢測到 lint 錯誤

**錯誤做法**：
```
檢測到 lint 錯誤 → 自動執行 pnpm run lint --fix → 繼續 commit
```

**正確做法**：
```
檢測到 lint 錯誤 → 停止 commit 流程 → 在 chat 中報告錯誤 → 詢問：「是否需要我協助修正這些問題？」 → 等待用戶回應 → 用戶同意後修復 → 繼續
```

### 場景 3：檢測到架構違規

**錯誤做法**：
```
檢測到 Provider 有 API 調用 → 自動重構 → 繼續 commit
```

**正確做法**：
```
檢測到 Provider 有 API 調用 → 停止 commit 流程 → 在 chat 中報告違規 → 提供修正建議和 Apply 按鈕 → 等待用戶選擇 → 用戶套用後繼續
```

## 與其他規則的整合

此規則與以下規則緊密相關，必須同時遵守：

1. **commit-and-mr-guidelines.mdc**：定義了 commit 流程中的代碼修改限制
2. **auto-commit-and-mr.md**：定義了自動化指令的執行流程

**重要**：當這些規則之間有衝突時，**此規則的優先級最高**。即使用戶要求執行自動化指令，如果檢測到需要修改代碼的問題，也必須先停止並詢問。

## 檢查清單

在執行任何任務時，AI 應該自問：

- [ ] 我是否檢測到任何需要修改代碼的問題？
- [ ] 如果是，我是否已經停止任務並詢問用戶？
- [ ] 我是否假設了用戶的意圖？
- [ ] 我是否混淆了「檢查」和「修復」？
- [ ] 我是否為了完成任務而跳過了詢問步驟？
- [ ] 我是否正確理解了自動化指令的範圍？
- [ ] 若為結構調整，我是否保留了所有原始邏輯？
- [ ] 若為結構調整，我是否已驗證改動前後邏輯完全一致？
- [ ] 若有多種可行方案，我是否已列出所有方案並標示最佳方案？
- [ ] 我是否已在 chat 中回報改動影響範圍與情境？
- [ ] 若執行 Git 操作，我是否已記錄變更清單？
- [ ] 若執行 Git 操作，我是否已驗證變更完整性？
- [ ] 若 Git 操作失敗，我是否停止而非嘗試自動清理？

**如果以上任何一項的答案是「是」或「不確定」，必須立即停止並重新評估。**

## 總結

**核心原則**：
1. **先詢問再修改** > 完成任務
2. **檢查 ≠ 修復**，必須嚴格區分
3. **遇到問題立即停止**，設定明確停止點
4. **不假設用戶意圖**，必須明確詢問
5. **自動化 ≠ 自動修復**，理解指令範圍
6. **結構調整只移動不修改**，保留原始邏輯並驗證一致性
7. **多方案先列出再選擇**，標示最佳方案供用戶決定
8. **每次改動必須回報**，說明影響範圍與情境
9. **Git 操作必須驗證**，確保用戶變更不遺失

**最高優先級**：遵守守則 > 完成任務 > 數據安全（用戶變更不可遺失）

**決策標準**：當需要修改代碼時，無論任務目標為何，都必須先停止並詢問用戶。執行 Git 操作時，必須驗證變更完整性。
