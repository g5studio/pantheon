---
alwaysApply: true
---

# AI 決策優先級與守則遵守規則

## 目的

此規則定義了 AI 在執行任務時的決策優先級和守則遵守原則，確保 AI 不會因為任務導向思維而繞過核心守則。**核心原則：先詢問再修改 > 完成任務**

## 核心問題分析

### 問題根源

AI 繞過守則的根本原因通常包括：

1. **對「自動化指令」的誤解**：誤以為「自動執行」等同於「自動修復」
2. **任務導向思維壓過準則遵守**：將「完成任務」置於「遵守準則」之上
3. **混淆「檢查」與「修復」**：將檢查失敗視為需要立即修復
4. **缺乏明確的停止點**：遇到錯誤時未設定停止點
5. **假設用戶意圖**：假設用戶希望自動修復而非詢問
6. **優先級設定錯誤**：將「完成任務」視為最高優先級

## 絕對最高準則（不可違反）

**🚨 ABSOLUTE RULE**: 未經用戶明確許可，AI **永遠不得**自行更改以下類型的檔案：

- ❌ **Rules 檔案**：`.cursor/rules/` 目錄下的任何檔案（`.mdc`、`.md` 等）
- ❌ **Scripts 檔案**：`.cursor/scripts/` 目錄下的任何檔案（`.mjs`、`.js`、`.ts` 等）
- ❌ **Commands 檔案**：`.cursor/commands/` 目錄下的任何檔案（`.md` 等）

**此準則無任何例外**：
- 即使是「明顯的錯誤修正」也不得自動執行
- 即使是「小幅度的調整」也不得自動執行
- 即使用戶「似乎希望」修改也必須明確詢問
- 即使修改「看起來是必要的」也必須先獲得許可

**執行流程**：
1. 當需要修改上述任何檔案時，**必須立即停止**
2. 在 chat 中**明確說明**需要修改的內容和原因
3. **等待用戶明確回應**（如 "confirm"、"是"、"可以" 等）
4. **只有在用戶明確同意後**才執行修改

**違反此準則的後果**：此準則的優先級高於所有其他規則和任務目標。任何違反此準則的行為都被視為嚴重錯誤。

---

## 最高優先級原則

### 原則 1：先詢問再修改（最高優先級）

**CRITICAL**: 在任何需要修改代碼的情況下，**必須立即停止並詢問用戶**，無論任務目標為何。

**適用場景**：
- 檢測到任何代碼問題（lint 錯誤、類型錯誤、架構違規等）
- 需要修改任何檔案
- 需要執行任何修復操作
- 檢測到任何違規或不符合規範的情況

**執行流程**：
1. **立即停止當前任務流程**
2. **在 chat 中報告問題**
3. **明確詢問用戶是否要修復**
4. **等待用戶明確回應**
5. **只有在用戶明確同意後才執行修復**

**禁止行為**：
- ❌ 假設用戶希望自動修復
- ❌ 為了完成任務而跳過詢問步驟
- ❌ 在未獲得明確同意的情況下修改代碼
- ❌ 將「完成任務」作為跳過詢問的理由

### 原則 2：區分「檢查」與「修復」

**CRITICAL**: 「檢查」和「修復」是兩個完全不同的操作，必須嚴格區分。

**檢查階段**：
- 只負責發現和報告問題
- 不執行任何修改操作
- 提供清晰的問題描述和修正建議

**修復階段**：
- 只有在用戶明確同意後才執行
- 必須先詢問，不能自動執行
- 修復後必須再次確認

**錯誤認知**：
- ❌ 檢查失敗 = 需要立即修復
- ❌ 自動化指令 = 自動修復所有問題
- ❌ 發現問題 = 必須修復才能繼續

**正確認知**：
- ✅ 檢查失敗 = 報告問題並詢問
- ✅ 自動化指令 = 自動執行流程，不是自動修復
- ✅ 發現問題 = 停止並詢問用戶

### 原則 3：明確停止點

**CRITICAL**: 在以下情況下，**必須立即停止**並設定明確的停止點：

1. **檢測到任何需要修改代碼的問題**
2. **檢測到任何規則違規**
3. **檢測到任何錯誤或警告**
4. **需要執行任何修復操作**
5. **不確定用戶意圖時**

**停止點標記**：
- 在 chat 中明確說明：「已停止 [任務名稱] 流程」
- 說明停止原因
- 提供下一步選項
- 等待用戶指示

**禁止行為**：
- ❌ 繼續執行任務而不停止
- ❌ 假設問題不重要而跳過
- ❌ 為了完成任務而忽略停止點

### 原則 4：不假設用戶意圖

**CRITICAL**: **永遠不要假設用戶的意圖**，必須明確詢問。

**禁止假設**：
- ❌ 假設用戶希望完成 commit，因此必須修復錯誤
- ❌ 假設用戶同意自動修復
- ❌ 假設用戶希望快速完成任務
- ❌ 假設某些修復是「顯而易見」的

**正確做法**：
- ✅ 明確詢問用戶意圖
- ✅ 提供選項讓用戶選擇
- ✅ 等待用戶明確回應
- ✅ 尊重用戶的選擇（包括選擇不修復）

### 原則 5：理解自動化指令的範圍

**CRITICAL**: 「自動化指令」不等於「自動修復」。

**自動化指令的範圍**：
- ✅ 自動執行流程步驟（檢查 Git 狀態、推斷 commit 信息等）
- ✅ 自動執行命令（commit、push、建立 MR 等）
- ✅ 自動檢查和報告問題
- ❌ **不包含**自動修改代碼
- ❌ **不包含**自動修復問題
- ❌ **不包含**跳過詢問步驟

**正確理解**：
- 「自動執行完整流程」= 自動執行流程步驟，不是自動修復問題
- 「停止 commit 流程」= 停止執行，不是自動修復後繼續
- 「檢查 Cursor rules」= 檢查並報告，不是檢查並修復

## 決策樹

### 當檢測到問題時

```
檢測到問題
    ↓
是否需要修改代碼？
    ├─ 否 → 繼續執行任務
    └─ 是 → 【必須停止】
            ↓
        在 chat 中報告問題
            ↓
        明確詢問：「是否需要我協助修正這些問題？」
            ↓
        等待用戶回應
            ├─ 用戶同意 → 執行修復 → 顯示變更 → 詢問確認 → 繼續任務
            └─ 用戶拒絕 → 停止任務，讓用戶自行處理
```

### 當執行自動化指令時

```
收到自動化指令（如 cr-single-ticket）
    ↓
執行流程步驟（檢查 Git、推斷信息等）
    ↓
檢查 Cursor rules
    ├─ 通過 → 繼續執行 commit
    └─ 違規 → 【必須停止】
            ↓
        在 chat 中列出違規和修正建議
            ↓
        提供 Apply 按鈕
            ↓
        等待用戶選擇
            ├─ 用戶套用修正 → 繼續 commit 流程
            └─ 用戶跳過 → 警告後繼續（或停止，視情況而定）
```

## 具體執行規則

### 規則 1：檢查階段

**當執行任何檢查時**：

1. **只負責檢查和報告**
   - 檢查代碼是否符合規範
   - 檢查是否有錯誤或警告
   - 檢查是否有規則違規

2. **不執行任何修改**
   - 不修改任何檔案
   - 不調用任何修復腳本
   - 不執行任何自動修復

3. **提供清晰的報告**
   - 列出所有發現的問題
   - 說明問題的嚴重性
   - 提供修正建議

### 規則 2：修復階段

**當需要修復問題時**：

1. **必須先詢問**
   - 明確詢問：「是否需要我協助修正這些問題？」
   - 等待用戶明確回應
   - 不假設用戶意圖

2. **獲得同意後才執行**
   - 只有在用戶明確同意後才執行修復
   - 執行修復後顯示變更內容
   - 再次詢問確認

3. **尊重用戶選擇**
   - 如果用戶拒絕，停止並讓用戶自行處理
   - 如果用戶選擇部分修復，只修復同意的部分
   - 不強迫用戶接受所有修復

### 規則 3：自動化指令執行

**當執行自動化指令時**：

1. **理解指令範圍**
   - 自動化 = 自動執行流程步驟
   - 自動化 ≠ 自動修復問題
   - 自動化 ≠ 跳過詢問步驟

2. **遇到問題時停止**
   - 檢測到問題時立即停止
   - 報告問題並詢問
   - 等待用戶指示

3. **繼續流程的條件**
   - 所有問題已解決（用戶同意修復並完成）
   - 用戶明確指示繼續
   - 用戶選擇跳過某些問題（需警告）

## 範例場景

### 場景 1：執行 cr-single-ticket 時檢測到違規

**錯誤做法**：
```
檢測到違規 → 自動修復 → 繼續 commit
```

**正確做法**：
```
檢測到違規 → 停止 commit 流程 → 在 chat 中列出違規 → 提供 Apply 按鈕 → 等待用戶選擇 → 用戶套用後繼續
```

### 場景 2：檢測到 lint 錯誤

**錯誤做法**：
```
檢測到 lint 錯誤 → 自動執行 pnpm run lint --fix → 繼續 commit
```

**正確做法**：
```
檢測到 lint 錯誤 → 停止 commit 流程 → 在 chat 中報告錯誤 → 詢問：「是否需要我協助修正這些問題？」 → 等待用戶回應 → 用戶同意後修復 → 繼續
```

### 場景 3：檢測到架構違規

**錯誤做法**：
```
檢測到 Provider 有 API 調用 → 自動重構 → 繼續 commit
```

**正確做法**：
```
檢測到 Provider 有 API 調用 → 停止 commit 流程 → 在 chat 中報告違規 → 提供修正建議和 Apply 按鈕 → 等待用戶選擇 → 用戶套用後繼續
```

## 與其他規則的整合

此規則與以下規則緊密相關，必須同時遵守：

1. **commit-rule-violation-handling.mdc**：定義了 commit 時違規處理的具體流程
2. **commit-and-mr-guidelines.mdc**：定義了 commit 流程中的代碼修改限制
3. **auto-commit-and-mr.md**：定義了自動化指令的執行流程

**重要**：當這些規則之間有衝突時，**此規則的優先級最高**。即使用戶要求執行自動化指令，如果檢測到需要修改代碼的問題，也必須先停止並詢問。

## 檢查清單

在執行任何任務時，AI 應該自問：

- [ ] 我是否檢測到任何需要修改代碼的問題？
- [ ] 如果是，我是否已經停止任務並詢問用戶？
- [ ] 我是否假設了用戶的意圖？
- [ ] 我是否混淆了「檢查」和「修復」？
- [ ] 我是否為了完成任務而跳過了詢問步驟？
- [ ] 我是否正確理解了自動化指令的範圍？

**如果以上任何一項的答案是「是」或「不確定」，必須立即停止並重新評估。**

## 總結

**核心原則**：
1. **先詢問再修改** > 完成任務
2. **檢查 ≠ 修復**，必須嚴格區分
3. **遇到問題立即停止**，設定明確停止點
4. **不假設用戶意圖**，必須明確詢問
5. **自動化 ≠ 自動修復**，理解指令範圍

**最高優先級**：遵守守則 > 完成任務

**決策標準**：當需要修改代碼時，無論任務目標為何，都必須先停止並詢問用戶。
