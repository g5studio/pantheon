---
alwaysApply: true
---

# 版本號跳板規則

此規則定義了版本號的格式、跳板邏輯，以及在不同專案中版本檔案的偵測方式。無論用戶是使用 `bump-version` command 或是在 chat 中直接交付版本更新任務，都必須遵循此規則。

## 適用場景

此規則適用於**所有**版本更新相關的操作，包括但不限於：
- 執行 `bump-version` command
- 在 chat 中直接請求版本更新
- 任何涉及修改版本號的任務

## 版本號格式定義

### 支援的版本格式

| 格式 | 範例 | 說明 |
|---|---|-----|
| `major.minor.patch` | `5.36.0` | 標準語意化版本 |
| `major.minor.patch-suffix` | `5.36.0-b` | STG 環境版本（suffix 為小寫英文字母） |
| `major.minor.patch-suffix.suffix` | `5.36.0-z.a` | STG 環境版本（超過 z 時追加） |
| `major.minor.patch-beta.N` | `0.0.0-beta.3` | Beta 版本（N 為數字） |

### 版本號規則

- `major`：主版本號，數字
- `minor`：次版本號，數字
- `patch`：修補版本號，數字
- `suffix`：STG 環境特徵編號，小寫英文字母（a-z），可用 `.` 連接多組
- `beta.N`：Beta 版本編號，N 為數字

## 跳板類型定義

### 1. 同環境進版（Same Environment Bump）

根據當前版本格式自動判斷跳板方式：

| 當前版本格式 | 跳板邏輯 | 範例 |
|------|-----|---|
| 帶有 STG suffix | 推進最後一個英文字母 | `5.36.0-b` → `5.36.0-c` |
| STG suffix 為 z | 追加 `.a` | `5.36.0-z` → `5.36.0-z.a` |
| STG suffix 為 z.z | 追加 `.a` | `5.36.0-z.z` → `5.36.0-z.z.a` |
| 帶有 beta.N | 推進 N 數字 | `0.0.0-beta.3` → `0.0.0-beta.4` |
| patch 不為 0 | 推進 patch | `5.36.1` → `5.36.2` |
| patch 為 0 | 推進 patch | `5.36.0` → `5.36.1` |

### 2. 環境升級（Environment Upgrade）

移除所有環境特徵編號：

| 當前版本格式 | 跳板邏輯 | 範例 |
|------|-----|---|
| 帶有 STG suffix | 移除 suffix | `5.36.0-z` → `5.36.0` |
| 帶有 beta.N | 移除 beta | `0.0.0-beta.3` → `0.0.0` |
| 無特徵編號 | 保持不變 | `5.36.0` → `5.36.0` |

## 版本檔案偵測規則

### 支援的版本檔案

| 檔案 | 版本欄位位置 | 適用專案 |
|---|----|----|
| `package.json` | `version` 欄位 | Node.js / npm 專案 |
| `build.properties` | `config.brands.*.ver` 配置（前 32 行） | Java / Gradle 專案 |
| `.cursor/version.json` | `version`、`pantheon` 或第一個 string 欄位 | Cursor 專案 |

### 偵測優先順序

**CRITICAL**: 執行版本更新時，必須按以下優先順序偵測版本檔案：

1. **package.json**（優先）
   - 如果存在且包含 `version` 欄位，使用此檔案
   - 如果同時存在 `build.properties`，兩個檔案都要更新

2. **build.properties**（次優先）
   - 如果 `package.json` 不存在或無效，使用此檔案

3. **.cursor/version.json**（最後）
   - 如果以上都不存在，使用此檔案

### 專案版本檔案對照表

根據專案名稱或結構，以下是常見專案的版本檔案配置：

| 專案類型 | 版本檔案 | 備註 |
|-----|-----|---|
| tiger-admin | `package.json` + `build.properties` | 兩個檔案都要更新 |
| fluid-two | `package.json` | 標準 npm 專案 |
| pantheon | `.cursor/version.json` | Cursor 專案 |
| 一般 npm 專案 | `package.json` | 標準配置 |
| Java 專案 | `build.properties` | Gradle 配置 |

## 執行流程規則

### 前置檢查

**CRITICAL**: 執行版本更新前，必須進行以下檢查：

1. **檢查未提交變更**
   - 如果有未提交的變更，必須停止並提示用戶
   - 提示：「請先提交或暫存變更後再執行版本更新」

2. **驗證版本檔案存在**
   - 確認至少一個版本檔案存在
   - 如果找不到任何版本檔案，必須停止並提示用戶

3. **驗證版本格式**
   - 確認當前版本號符合支援的格式
   - 如果格式無效，必須停止並提示用戶

### 執行步驟

1. 偵測並確認版本檔案
2. 讀取當前版本號
3. 詢問用戶選擇跳板類型（同環境進版 / 環境升級）
4. 計算新版本號
5. 詢問用戶確認
6. 更新所有版本檔案
7. 提交變更（commit message 格式：`chore: bump version {舊版本} -> {新版本}`）
8. 推送到遠端

### Commit Message 規則

| 情境 | Commit Message 格式 |
|---|-----|
| 分支包含 Jira ticket | `chore({TICKET}): bump version {old} -> {new}` |
| 分支不包含 ticket | `chore: bump version {old} -> {new}`（跳過 commitlint） |

## AI 執行版本更新的規則

**CRITICAL**: 當用戶在 chat 中請求版本更新時，AI 必須遵循以下規則：

### 1. 自動偵測版本檔案

AI 必須根據「版本檔案偵測規則」自動偵測專案的版本檔案，不需要用戶明確指定。

### 2. 明確詢問跳板類型

如果用戶沒有明確指定跳板類型，AI **必須**詢問：
- 「同環境進版」：推進版本號
- 「環境升級」：移除環境特徵編號

### 3. 確認後執行

執行版本更新前，AI **必須**向用戶確認：
- 當前版本號
- 新版本號
- 將更新的檔案列表

### 4. 使用腳本執行

AI 應該使用 `.cursor/scripts/utilities/bump-version.mjs` 腳本執行版本更新：

```bash
node .cursor/scripts/utilities/bump-version.mjs --files="{檔案列表}" --type={跳板類型} --yes
```

### 5. 報告執行結果

執行完成後，AI 必須報告：
- 更新後的版本號
- 更新的檔案列表
- Commit hash
- 推送狀態

## 範例

### 範例 1：用戶請求同環境進版

```
用戶：「幫我跳版」

AI 應該：
1. 偵測版本檔案（如 package.json）
2. 讀取當前版本（如 5.36.0-b）
3. 詢問：「請選擇跳板類型：1. 同環境進版 2. 環境升級」
4. 用戶選擇 1
5. 確認：「將把版本從 5.36.0-b 更新為 5.36.0-c，是否確認？」
6. 執行腳本並報告結果
```

### 範例 2：用戶直接指定類型

```
用戶：「幫我做環境升級」

AI 應該：
1. 偵測版本檔案
2. 讀取當前版本（如 5.36.0-z）
3. 確認：「將把版本從 5.36.0-z 更新為 5.36.0，是否確認？」
4. 執行腳本並報告結果
```

## 注意事項

1. **必須先提交所有變更**：版本更新前不能有未提交的變更
2. **自動推送**：版本更新完成後會自動推送到遠端
3. **多檔案同步**：如果專案有多個版本檔案，必須全部更新
4. **格式驗證**：更新前後都要驗證版本格式正確
