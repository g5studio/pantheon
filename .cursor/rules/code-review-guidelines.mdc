---
description: 
globs: 
alwaysApply: true
---
# Code Review Guidelines

This rule outlines the key checks to perform when reviewing code in the `fluid` project, ensuring adherence to established architectural patterns and best practices.

## Core Principle: Adherence to Architecture

The primary goal of any code review is to verify that the changes align with the project's defined architecture.

*   **MUST:** Before starting a review, familiarize yourself with the latest version of the [architecture-overview.mdc](mdc:.cursor/rules/architecture-overview.mdc) rule.
*   **MUST:** Explicitly check the code against the principles and patterns described in `architecture-overview.mdc`, especially those related to state management and component types.

## Key Review Checkpoints

### 1. State Management

*   **Global State:** Is global state (like user info, system settings) accessed/managed correctly via the designated singleton hooks (e.g., `use-user-info.ts`, `use-system-info.ts`) as described in `architecture-overview.mdc`?
*   **Server State (API Data):**
    *   Is TanStack Query (`@tanstack/solid-query`) used for fetching, caching, and mutating server state?
    *   Are the standard wrappers (`createCustomizeQuery`, `createCustomizeMutation`, etc.) used where appropriate?
*   **Context API (`createContext`):**
    *   Is Context used for appropriate scoped state sharing (UI state, configuration)?
    *   **CRITICAL:** Does the `Provider` component itself perform **any** side effects, especially API calls (e.g., `createQuery`, `createCustomizeQuery`)? This is **strictly forbidden** by the [architecture-overview.mdc](mdc:.cursor/rules/architecture-overview.mdc). API calls belong in `Controller` components or potentially `Service` components if tightly coupled to a specific feature flow, but *never* directly in a Provider. Providers should only expose state and pure update functions.
*   **Local State:** Is `createSignal` used appropriately for simple, component-local state?
*   **Stores (`createStore`):** Is `createStore` used for complex component/module state, often defined in `.model.ts` files?

### 2. Component Patterns

*   **`Provider`:** Is it correctly named and used solely for providing context value via the standard SolidJS Context API? Does it avoid side effects?
*   **`Controller`:** If the component orchestrates background tasks, manages cross-cutting concerns, or handles data initialization/API calls without rendering direct UI, is it named `Controller`? Does it return an empty fragment (`<></>`) or trigger UI indirectly (modals, notifications)?
*   **`Service`:** If the component bundles UI, state, logic, and API calls for a specific user task/feature, is it potentially a `Service` component (often in `services/` directories)? Unlike Controllers, Services should perform side effects AND return UI elements, following a render props pattern to encapsulate both business logic and user interface for a specific feature flow.
*   **Standard Components:** Are presentational components correctly placed (e.g., within `components/`)?

### 3. SolidJS Best Practices

*   Are custom hooks adhering to SolidJS principles (e.g., using accessors for reactive props, returning signals/stores)? Refer to `solid-hook-best-practices.mdc` if reviewing hooks.
*   Is cleanup handled correctly (e.g., using `onCleanup`)?

### 4. Code Structure and Location

*   Are files placed in the correct directories according to the modular structure (`src/modules/`, `src/shared/`) outlined in `architecture-overview.mdc`?
*   Are naming conventions followed?

### 5. Code Smells and Common Development Principles

*   **SOLID Principles:**
    *   **Single Responsibility:** Does each component, function, and class have a single, well-defined responsibility?
    *   **Open/Closed:** Is code written to be extensible without modification?
    *   **Liskov Substitution:** Do derived components maintain the expected behavior of their base components?
    *   **Interface Segregation:** Are component props and interfaces focused and minimal?
    *   **Dependency Inversion:** Do high-level components depend on abstractions rather than concrete implementations?

*   **DRY (Don't Repeat Yourself):**
    *   Is there duplicated logic that could be extracted into shared functions/components?
    *   Are there repeated patterns that could be abstracted into reusable hooks or utilities?

*   **Common Code Smells:**
    *   **Long Functions/Components:** Are there functions or components longer than 100 lines that could be decomposed?
    *   **Complex Conditionals:** Are there nested if/else blocks or complex boolean expressions that could be simplified?
    *   **Excessive Props:** Do components have more than 7-8 props, indicating they might need splitting?
    *   **Prop Drilling:** Is state being passed through multiple layers of components unnecessarily?
    *   **Magic Numbers/Strings:** Are there unexplained literal values that should be constants?
    *   **Comments Explaining "How":** Does the code require comments to explain how it works (rather than why), indicating it's not self-explanatory?
    *   **Side Effects in Unexpected Places:** Are there side effects (API calls, state changes) happening outside of designated locations?
    *   **Deeply Nested JSX:** Are there components with JSX nesting deeper than 4-5 levels?

*   **Performance Considerations:**
    *   **Unnecessary Re-renders:** Are there missing memoization opportunities or signals being recreated in render functions?
    *   **Large Bundles:** Are there unnecessarily large imports or dependencies?
    *   **Resource Leaks:** Are all listeners, observers, and resources properly cleaned up?
        *   **Component-by-Component Verification:** When reviewing components, especially those nested within larger files, evaluate each component's actual cleanup needs based solely on its implementation. Don't assume cleanup requirements based on surrounding components or file context. Only flag missing cleanup when the component actually sets up listeners, timers, subscriptions, or other resources that need explicit disposal.
        *   **API Hooks Exception:** The custom hooks `createCustomizeQuery`, `createCustomizeMutation`, and `createCustomizeInfiniteQuery` are wrappers around TanStack Query functionality that automatically handle their own cleanup when components unmount. These do NOT require explicit cleanup in components and should NEVER be flagged as potential resource leaks.

*   **Error Handling:**
    *   Is error handling comprehensive and user-friendly?
    *   Are API errors appropriately caught and handled?
    *   Are edge cases considered?

*   **Security:**
    *   Is user input properly sanitized before use?
    *   Are there potential injection vulnerabilities?
    *   Is sensitive data properly protected?

## Standardized Review Format

All code reviews MUST follow this standardized format:

```
# Code Review: [File/Component Name]

## Summary

[1-2 sentence overview of the code and its purpose]

[Brief statement about the overall quality - mention if there are critical issues]

## Critical Issues ðŸš¨

[List ANY architectural violations or serious bugs that MUST be fixed]
[If none, state "No critical issues found"]

## Code Smells and Improvements

### State Management
- [Comments about state management approaches]

### Component Structure
- [Comments about component organization and responsibilities]

### Code Quality
- [Specific issues like duplication, complexity, or readability concerns]

### Performance
- [Any performance considerations]

### Other
- [Any other observations]

## Recommendations

[Prioritized list of suggested changes]
```

### Review Example

```
# Code Review: UserProfileCard/index.tsx

## Summary

This component displays a user profile card with avatar, name, stats, and actions. It fetches data directly inside the component rather than using the established patterns.

The implementation has critical architectural violations and several code quality issues.

## Critical Issues ðŸš¨

- [Violation]ðŸš¨ API calls are made directly in the component using `fetch` instead of using TanStack Query or the standard wrappers (`createCustomizeQuery`)
- [Violation]ðŸš¨ Directly manipulates DOM outside of SolidJS reactivity system with `document.querySelector`

## Code Smells and Improvements

### State Management
- Local state is created with `useState` instead of SolidJS's `createSignal`
- User data should be accessed through `use-user-info` rather than direct API calls
- No error handling for failed API requests

### Component Structure
- Component has multiple responsibilities (fetching data, rendering profile, handling actions)
- Should be split into smaller components (ProfileHeader, ProfileStats, ProfileActions)

### Code Quality
- Function `handleUserActions` is 85 lines long and handles 4 different actions
- Duplicate string literals for status values ("active", "pending") should be constants
- Deep nesting of conditional rendering (4 levels) makes the JSX hard to follow

### Performance
- Missing cleanup for event listeners in useEffect
- Avatar image has no loading strategy or fallback

### Other
- Inconsistent naming convention (camelCase mixed with PascalCase for handlers)

## Recommendations

1. Move API calls to a Controller component or use proper TanStack Query patterns
2. Split component into smaller, focused sub-components
3. Refactor `handleUserActions` into separate functions for each action
4. Extract string literals to constants
5. Add proper error handling
6. Implement cleanup for event listeners
7. Follow consistent naming conventions
```

## Review Process

1.  Read the changes and understand their purpose.
2.  **Check Related Files:** Identify and review the implementation of any imported custom hooks, components, or utilities, especially those from `src/shared/` or used across multiple files. Don't review files in isolation.
3.  Consult [architecture-overview.mdc](mdc:.cursor/rules/architecture-overview.mdc).
4.  Consult other relevant rules (e.g., `solid-hook-best-practices.mdc`, `shared-hook-state-check.mdc` if applicable).
5.  Systematically check the code (both the changed file and related implementations) against the checkpoints listed above.
6.  Provide clear feedback, referencing specific rules or patterns when necessary.
7.  Format your review using the standardized template.
