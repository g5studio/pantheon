---
description: 問題定位功能：無法重現/機率性發生的線上問題排查，透過逆向工程方式定位問題根源
---

當用戶輸入 `reverse-engineering` 時，**所有交互都在 Cursor chat 中完成**，執行以下完整流程：

## 流程說明

### 1. 詢問 Jira 單號

- **步驟 1: 詢問 Jira 單號**（必填）
  - 格式：`FE-1234`、`IN-5678` 或完整 URL
  - 無法省略，必須提供
  - 會驗證格式是否正確

### 2. 讀取 Jira Ticket 資訊

- 使用 Jira API 獲取 ticket 的詳細信息（標題、描述、狀態、負責人、優先級等）
- 讀取 ticket 的評論（comments）以了解問題背景
- 在 chat 中顯示 ticket 基本信息

### 3. 執行四個步驟的引導流程

#### 步驟 1：定位（Location）

**目標**：從 TCS 及各方業主提供的資訊，按照頻率、回報數多寡、是否跨端口、是否跨業主可以快速推導出問題源頭是前端、後端、線路、裝置快取問題

**執行流程**：
1. **讀取 ticket 描述和評論**：整理單本身描述的情況
2. **引導用戶提供補充資訊**：
   - 問題發生頻率（高/中/低）
   - 回報數量（多少人/次回報）
   - 是否跨端口（PC/Mobile/WAP）
   - 是否跨業主（單一業主/多個業主）
   - TCS 提供的相關資訊
   - 各方業主提供的資訊
3. **分析並推導問題源頭**：
   - 根據收集的資訊分析問題可能來源
   - 判斷是前端、後端、線路、裝置快取問題
4. **與用戶確認**：顯示分析結果，詢問是否有需要補充的內容

**輸出格式**：
```
📍 步驟 1：定位

📋 已整理的問題資訊：
- 問題描述：[從 ticket 描述提取]
- 發生頻率：[用戶提供]
- 回報數量：[用戶提供]
- 跨端口情況：[用戶提供]
- 跨業主情況：[用戶提供]
- TCS 資訊：[用戶提供]
- 業主資訊：[用戶提供]

🔍 問題源頭分析：
根據以上資訊，問題可能來源為：
- [前端/後端/線路/裝置快取]（可能性：高/中/低）
- 分析依據：[具體說明]

❓ 是否有需要補充的內容？
```

#### 步驟 2：盤點（Inventory）

**目標**：按 TCS 回報的內容先找到終端反饋的問題節點向上找到根節點後盤出完整邏輯樹，99% 在 a 階段就應該定位出是否為我方 program 問題，因此在 b 階段要假定 API 都有正常獲取資料也無異常，列出所有可能性後按高到低排序

**執行流程**：
1. **引導用戶提供 TCS 回報內容**：
   - 終端反饋的問題節點（用戶看到什麼錯誤/異常）
   - 問題發生的操作流程
   - 相關的頁面/功能模組
2. **向上追蹤根節點**：
   - 從終端問題節點向上追蹤到根節點
   - 盤出完整的邏輯樹（數據流、函數調用鏈等）
3. **列出所有可能性**：
   - 假定 API 都有正常獲取資料也無異常
   - 列出所有可能導致問題的原因
   - 按可能性由高到低排序
4. **整理成報告並與用戶確認**：完成後整理成報告給用戶確認

**輸出格式**：
```
📊 步驟 2：盤點

📋 TCS 回報內容：
- 終端問題節點：[用戶提供的問題描述]
- 操作流程：[用戶提供的操作步驟]
- 相關模組：[用戶提供的模組資訊]

🌳 完整邏輯樹：
[繪製從根節點到問題節點的完整邏輯樹]
根節點 → 中間節點 1 → 中間節點 2 → ... → 問題節點

🔍 所有可能性分析（按可能性排序）：
1. [可能性最高的原因]（可能性：高）
   - 說明：[具體說明]
2. [可能性次高的原因]（可能性：中）
   - 說明：[具體說明]
3. [可能性較低的原因]（可能性：低）
   - 說明：[具體說明]

❓ 此盤點結果是否正確？請確認。
```

#### 步驟 3：情搜（Intelligence）

**目標**：按盤點出的邏輯樹將根節點到問題節點中間所有使用到的 API 發給 BE 取得相關 log，繪製完整 data roadmap 給用戶確認，並列出需要的 API log 請用戶提供

**執行流程**：
1. **根據邏輯樹識別所有 API**：
   - 從根節點到問題節點中間所有使用到的 API
   - 列出每個 API 的用途和重要性
2. **繪製完整 data roadmap**：
   - 顯示數據從 API 到終端的完整流程
   - 標註每個 API 的數據轉換點
3. **列出需要的 API log**：
   - 根據邏輯樹和可能性分析，列出需要查看的 API log
   - 說明每個 log 的用途
4. **引導用戶提供 API log**：請用戶提供相關的 API log

**輸出格式**：
```
🔍 步驟 3：情搜

📊 完整 Data Roadmap：
[繪製從根節點到問題節點的完整數據流程圖]
API 1 → 數據轉換 1 → API 2 → 數據轉換 2 → ... → 終端顯示

📋 需要的 API Log 清單：
1. GET /api/v1/xxx
   - 用途：[說明此 API 的用途]
   - 重要性：[高/中/低]
   - 需要查看的欄位：[列出需要關注的欄位]
2. POST /api/v1/yyy
   - 用途：[說明此 API 的用途]
   - 重要性：[高/中/低]
   - 需要查看的欄位：[列出需要關注的欄位]
...

❓ 請提供以上 API 的相關 log（可分批提供）。
```

#### 步驟 4：推導（Deduction）

**目標**：根據盤點出的所有 case 逐一帶入 log 對應的真實資料模仿 compiler 進行逆向追蹤，找出哪一節點開始出錯後，將所有可能導致此錯誤的原因按照可能性由高至低整理與對應的修正方式成報告給用戶確認

**執行流程**：
1. **模擬 runtime 運作**：
   - 根據步驟 2 盤點出的所有 case
   - 逐一帶入步驟 3 提供的 log 對應的真實資料
   - 模仿 compiler 進行逆向追蹤
2. **找出錯誤節點**：
   - 識別哪一節點開始出錯
   - 分析錯誤的具體表現
3. **整理可能原因和修正方式**：
   - 將所有可能導致此錯誤的原因按照可能性由高至低整理
   - 為每個原因提供對應的修正方式
4. **生成完整報告**：整理成報告給用戶確認

**輸出格式**：
```
🔬 步驟 4：推導

🔄 模擬 Runtime 運作結果：
[根據 log 資料模擬運作過程]
節點 1: [正常] → 節點 2: [正常] → 節點 3: [❌ 錯誤開始] → 節點 4: [錯誤延續]

❌ 錯誤節點：節點 3
- 錯誤表現：[具體描述錯誤]
- 錯誤數據：[相關的數據值]

🔍 可能原因分析（按可能性排序）：
1. [原因 1]（可能性：高）
   - 說明：[具體說明]
   - 修正方式：[具體的修正方案]
2. [原因 2]（可能性：中）
   - 說明：[具體說明]
   - 修正方式：[具體的修正方案]
3. [原因 3]（可能性：低）
   - 說明：[具體說明]
   - 修正方式：[具體的修正方案]

❓ 此推導結果是否正確？請確認執行方案。
```

### 4. 生成完整報告

當四個步驟都完成後，生成完整的逆向工程報告：

**報告格式**：
```markdown
# 逆向工程問題定位報告

## 📋 問題資訊
- **Jira Ticket**: [TICKET](URL)
- **標題**: [SUMMARY]
- **類型**: [ISSUE_TYPE]
- **狀態**: [STATUS]

## 📍 步驟 1：定位
[步驟 1 的完整內容]

## 📊 步驟 2：盤點
[步驟 2 的完整內容]

## 🔍 步驟 3：情搜
[步驟 3 的完整內容]

## 🔬 步驟 4：推導
[步驟 4 的完整內容]

## ✅ 結論與建議
[總結所有分析結果，提供最終的修正建議]
```

### 5. 🚨 強制停止點：用戶確認推導結果（留言前）

**CRITICAL**：在將報告留言到 Jira 之前，必須先讓用戶確認推導結果與要留言的最終報告內容。

**必須輸出的格式**（需完整呈現，供用戶確認）：
```
✅ 已完成逆向工程推導，以下為最終推導結論與報告內容預覽：

📌 最終推導結論（Deduction Summary）
- 錯誤節點：{NODE}
- 最可能原因（Top 1）：{CAUSE}
- 建議修正方向：{SUGGESTION}

📝 即將留言到 Jira 的完整報告（請確認）
============================================================
{REPORT_CONTENT}
============================================================

❓ 請回覆「confirm」確認留言到 Jira。
（若需要調整內容，請直接指出要修改的段落/句子，我會更新後再請你 confirm）
```

**禁止行為**：
- ❌ 未經用戶明確回覆 `confirm` 就留言到 Jira
- ❌ 未經用戶確認就轉進 start-task

### 6. 將報告留言到 Jira 單內

**CRITICAL**：用戶回覆 `confirm` 後，**必須**將報告留言到 Jira 單內。

使用腳本將報告留言到 Jira：
```bash
node .cursor/scripts/jira/add-jira-comment.mjs <TICKET> "<報告內容>"
```

**注意**：如果專案是以 submodule 形式掛載 Pantheon，請使用：
```bash
node .pantheon/.cursor/scripts/jira/add-jira-comment.mjs <TICKET> "<報告內容>"
```

**CRITICAL**：若留言失敗（腳本回傳 error），必須立即停止並在 chat 中呈現錯誤資訊，等待用戶指示後續處理方式。

### 7. 轉進 start-task 流程（視同「start-task + 謹慎模式」）

**CRITICAL**：完成報告留言後，**必須**轉進 start-task 流程，並且**視同用戶是透過 `start-task` 並選擇「謹慎模式」**來處理同一張 Jira card。

這代表：
- **行為模式**：已確定為「謹慎模式」，等同於用戶在 start-task 的模式選擇輸入 `1`
- **後續流程**：必須**完全與執行 start-task 謹慎模式時相同**（包含所有強制停止點、每步確認、最小改動與影響範圍說明等）
- **不得走捷徑**：除了「模式選擇已被確定」這件事外，其餘流程不得省略

執行方式：
- 在 chat 中提示用戶：「報告已留言到 Jira，現在轉進 start-task 流程（視同謹慎模式）開始修復」
- 後續交互依照 [`start-task.md`](mdc:.cursor/commands/operator/start-task.md) 與 [`operation-modes.mdc`](mdc:.cursor/rules/operator/start-task/operation-modes.mdc) 的謹慎模式規範執行

詳細執行規範請參考：
- [reverse-engineering-execution.mdc](mdc:.cursor/rules/operator/reverse-engineering-execution.mdc)

## 使用方式

- `reverse-engineering`：開始逆向工程問題定位流程

## 執行範例

```
用戶輸入: reverse-engineering

AI: 🔍 開始逆向工程問題定位

    📋 請提供 Jira 單號（格式: FE-1234, IN-5678，必填）：

用戶輸入: IN-101061

AI: 📖 正在讀取 Jira ticket IN-101061...
    [顯示 ticket 基本信息]
    
    📍 步驟 1：定位
    [執行定位步驟...]
    
    📊 步驟 2：盤點
    [執行盤點步驟...]
    
    🔍 步驟 3：情搜
    [執行情搜步驟...]
    
    🔬 步驟 4：推導
    [執行推導步驟...]
    
    ✅ 生成完整報告...
    ❓ 請回覆「confirm」確認留言到 Jira
    
用戶輸入: confirm

AI: 💬 正在將報告留言到 Jira 單內...
    ✅ 報告已留言到 Jira
    
    🔄 轉進 start-task 流程（視同謹慎模式）...
    [執行 start-task 流程]
```

## 注意事項

1. **必須完成所有四個步驟**：每個步驟都需要用戶確認後才能進入下一步
2. **報告必須留言到 Jira**：完成四個步驟後，必須將報告留言到 Jira 單內
3. **必須轉進 start-task**：報告留言後，必須轉進 start-task 流程，使用謹慎模式
4. **需要 Jira API 認證**：需要有效的 Jira API token 才能讀取 ticket 和留言
5. **參考範例**：可參考 [IN-101061](https://innotech.atlassian.net/browse/IN-101061) 的逆向工程範例

## 相關規則

- [start-task.md](mdc:.cursor/commands/operator/start-task.md)：start-task 流程規範
- [operation-modes.mdc](mdc:.cursor/rules/operator/start-task/operation-modes.mdc)：行為模式規範（謹慎模式）
- [reverse-engineering-execution.mdc](mdc:.cursor/rules/operator/reverse-engineering-execution.mdc)：reverse-engineering 專屬執行規範（留言前確認、留言後等同謹慎模式）

